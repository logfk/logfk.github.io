
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>终·搜索 - Absolute</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="前言这应该是我讲搜索的最后一版课件了，里面大概有三个课件的内容，一次讲不完也很正常。（
这一版拥有几乎全部的搜索内容（不一定），所以你能见到的大部分搜索都可以用这里的知识解决（大概）。
（由于博客不,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Absolute" type="application/atom+xml"> 
    <link rel="icon" href="/img/69671.jpg"> 
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Absolute</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://logfk.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">终·搜索</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">终·搜索</h1>
        <div class="stuff">
            <span>十一月 20, 2021</span>
            

        </div>
        <div class="content markdown">
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这应该是我讲搜索的最后一版课件了，里面大概有三个课件的内容，一次讲不完也很正常。（</p>
<p>这一版拥有几乎全部的搜索内容（不一定），所以你能见到的大部分搜索都可以用这里的知识解决（大概）。</p>
<p>（由于博客不支持目录所以没有目录了）</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="搜索简介"><a href="#搜索简介" class="headerlink" title="搜索简介"></a>搜索简介</h2><p>搜索是一种神奇的算法，它在大部分题目中不是正解，但是却能在大部分情况下拿到分，有时很高，有时很低，但总归是有分。（</p>
<h2 id="搜索分类"><a href="#搜索分类" class="headerlink" title="搜索分类"></a>搜索分类</h2><p>基本：dfs,bfs。</p>
<p>进阶：dfs 剪枝，bfs 优化，A*，迭代加深优化。</p>
<p>私货：DLX。</p>
<h2 id="一-基础"><a href="#一-基础" class="headerlink" title="一.基础"></a>一.基础</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>以深度为基本遍历顺序的搜索方式，其搜索顺序是树形的。</p>
<p><img src="/2021/11/20/%E7%BB%88%C2%B7%E6%90%9C%E7%B4%A2/dfs树.PNG" alt></p>
<p>节点上的数字便是 dfs 的遍历顺序。</p>
<p>所以说我们认为 dfs 这个东西实现是十分简单的，它使用了递归的操作，分为两（三）部分，递归边界（剪枝）和递归转移，它最大的不同就是递归时有更多的选择（bushi）。</p>
<h5 id="例-1-数字三角形"><a href="#例-1-数字三角形" class="headerlink" title="例 1 数字三角形"></a>例 1 数字三角形</h5><p>给定一个包含数字的n阶三角形，要求找到一条从三角形顶到底的一条路径，使得路径上所有数的和最大，并输出这个最大值。</p>
<p>样例输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure>
<p>样例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure>
<p>也许你曾经见过这道题，而且你可能想用递推（或者说 dp）做这道题，但递推的本质其实是能找到合理规律的递归，所以如果数据范围小的话完全是可以过的。</p>
<h5 id="例-2-八皇后问题"><a href="#例-2-八皇后问题" class="headerlink" title="例 2 八皇后问题"></a>例 2 八皇后问题</h5><p>（不知道你们讲没讲过总之之前课件上有就扒下来了。</p>
<p>给定一个 8*8 的国际象棋棋盘，求在此棋盘上不重叠地放置八个皇后的方案。</p>
<p>要求：</p>
<p>皇后之间不能互相吃。</p>
<p>单个皇后的攻击范围为它的八个方向的直线。（上、下、左、右、左上、左下、右上、右下）</p>
<p>搜索最关键的地方就是判断转移是否成立，所以我们一定要把能否放置皇后的标志（flag）建立出来。</p>
<p>对于一个地方是否可以放置皇后，只需要判断在该行、该列以及斜对角上上是否有皇后即可。</p>
<p>针对行：记录数组 $a_i$判断第i行是否已放置了皇后。（可以省略）</p>
<p>针对列：记录数组 $b_i$ 判断第i列是否已放置了皇后。</p>
<p>针对左斜对角线：记录数组 $c_i$ 判断第 $i+j$ 个左斜对角线是否已有棋子。</p>
<p>针对右斜对角线：记录数组 $d_i$ 判断第 $i-j+7$ 个右斜对角线是否已有棋子。</p>
<p>（最后会有更快乐的算法高效解决这个问题。）</p>
<p>一些简单的好题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1460">P1460 [USACO2.1]健康的荷斯坦奶牛 Healthy Holsteins</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1706">P1706 全排列问题</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1596">P1596 [USACO10OCT]Lake Counting S</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2196">P2196 挖地雷</a></p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>以层次为基本遍历顺序的搜索方法，其搜索顺序显而易见是按层数来的。</p>
<p><img src="/2021/11/20/%E7%BB%88%C2%B7%E6%90%9C%E7%B4%A2/bfs树.png" alt></p>
<p>树，但是是 bfs 序。</p>
<p>bfs 是要通过队列实现的，每次遍历到的点都进入到队尾，然后每次从队首找到一个点进行遍历（有的不是这样，是魔改的 bfs）。</p>
<h5 id="例-1-求细胞数量"><a href="#例-1-求细胞数量" class="headerlink" title="例 1 求细胞数量"></a>例 1 求细胞数量</h5><p>一矩形阵列由数字 0 到 9 组成，数字 1 到 9 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。</p>
<p>样例输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 10 </span><br><span class="line">0234500067</span><br><span class="line">1034560500</span><br><span class="line">2045600671</span><br><span class="line">0000000089</span><br></pre></td></tr></table></figure>
<p>样例输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>其实这个东西有一个更为规范的叫法——联通块。</p>
<p>根据题意，联通块有四联通，八连通..等等，我们直接一个简单的 bfs 敲上去，这题就出来了。</p>
<h5 id="例-2-洛谷P2730-USACO3-2-魔板-Magic-Squares"><a href="#例-2-洛谷P2730-USACO3-2-魔板-Magic-Squares" class="headerlink" title="例 2 洛谷P2730 [USACO3.2]魔板 Magic Squares"></a>例 2 洛谷P2730 [USACO3.2]魔板 Magic Squares</h5><p>一张有8个大小相同的格子的魔板：</p>
<p>1  2  3  4</p>
<p>8  7  6  5</p>
<p>这里提供三种基本操作，分别用大写字母“A”，“B”，“C”来表示（可以通过这些操作改变魔板的状态）：</p>
<p>“A”：交换上下两行；“B”：将最右边的一列插入最左边；“C”：魔板中央四格作顺时针旋转。</p>
<p>下面是对基本状态进行操作的示范：</p>
<p>A:  8  7  6  5</p>
<p>​     1  2  3  4</p>
<p>B:  4  1  2  3</p>
<p>​     5  8  7  6</p>
<p>C:  1  7  2  4</p>
<p>​     8  6  3  5</p>
<p>对于每种可能的状态，这三种基本操作都可以使用。</p>
<p>你要编程计算用最少的基本操作完成基本状态到目标状态的转换，输出基本操作序列。</p>
<p>样例输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 6 8 4 5 7 3 1 </span><br></pre></td></tr></table></figure>
<p>样例输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">BCABCCB</span><br></pre></td></tr></table></figure>
<p>bfs有判重需要，如果我们采用不经过变化的 hash，将这个序列存在 $9*10^7$ 的数组里，程序就会炸掉，所以这道题还需要引入一个神奇的东西——康托展开。（stl_map:?）</p>
<p>使用康托展开可以将一个任意进制的数转换为十进制的数，在这道题中，我们用康托展开可以把数组空间节省至 8!=40320，是一个很大的优化。</p>
<p>好题</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3930">P3930 SAC E#1 - 一道大水题 Knight</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1902">P1902 刺杀大使</a></p>
<h2 id="二-进阶"><a href="#二-进阶" class="headerlink" title="二.进阶"></a>二.进阶</h2><h3 id="DFS-剪枝"><a href="#DFS-剪枝" class="headerlink" title="DFS 剪枝"></a>DFS 剪枝</h3><p>你发现一些带着搜索tag的似乎用搜索做会TLE？</p>
<p>发现别人搜索的得分高说他不讲武德？</p>
<p>我说他们是瞎打的，朋友们啊，他们可不是瞎打，他们用了剪枝。</p>
<p>剪枝，顾名思义，我们会对我们的搜索树做一些不可描述的事情。</p>
<p>看见那些没用的状态了吗？</p>
<p>咔嚓一剪刀，树就被阉割了，他的负担就更少了，就跑的快了。</p>
<p>那么问题来了，怎么剪枝呢？</p>
<p>其实剪枝这事还挺简单的</p>
<p>比如你看见这里有棵树——</p>
<p>树呢？（剪没了）</p>
<p><strong>你的剪枝一定需要保证是正确的！！！</strong></p>
<p>剪枝的分类：上下界（玄学）剪枝，可行性（玄学）剪枝，最优化（玄学）剪枝，其他（玄学）剪枝。</p>
<h4 id="上下界剪枝"><a href="#上下界剪枝" class="headerlink" title="上下界剪枝"></a>上下界剪枝</h4><p>这个东西十分直观，我们不需要什么花里胡哨的东西就能够理解，比如说拆数，总不能把 4 拆成 5+(-1) 吧。</p>
<p>因此，我们标定搜索的上下界，防止不必要的搜索节产生。</p>
<h5 id="例-P1025-数的划分"><a href="#例-P1025-数的划分" class="headerlink" title="例 P1025 数的划分"></a>例 P1025 数的划分</h5><p>将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同(不考虑顺序)。</p>
<p>例如：$n=7$，$k=3$，下面三种分法被认为是相同的。</p>
<p>$1,1,5$;  $1,5,1$;  $5,1,1$。</p>
<p>问有多少种不同的分法。</p>
<p>样例输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br></pre></td></tr></table></figure>
<p>样例输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>对于这题，我们可以标定搜索的上下界，因为要求产生的数列不能够重复，所以我们搜索的下界是不能小于之前选过的数的最大值的。</p>
<p>同时，如果选的数字过大可能导致后边无数可拆，所以我们还要使用上界来对这个条件进行规划</p>
<p>加上上下界的标定后这题用 dfs 跑着就十分简单了。</p>
<h4 id="搜索顺序"><a href="#搜索顺序" class="headerlink" title="搜索顺序"></a>搜索顺序</h4><p>依据题目规定搜索的顺序（从大到小，从小到大 or 玄学）。</p>
<h4 id="可行性剪枝"><a href="#可行性剪枝" class="headerlink" title="可行性剪枝"></a>可行性剪枝</h4><p>考虑当前转移是否符合题意，不符合删去。</p>
<h5 id="例-UVA529-Addition-Chains"><a href="#例-UVA529-Addition-Chains" class="headerlink" title="例 UVA529 Addition Chains"></a>例 UVA529 Addition Chains</h5><p>一个与 $n$ 有关的整数加成序列 $<a_0,a_1,a_2,...,a_m>$ 满足以下四个条件：</a_0,a_1,a_2,...,a_m></p>
<p>1.$a_0=1$</p>
<p>2.$a_m=n$</p>
<p>3.$a_0&lt;a_1&lt;a_2&lt;…&lt;a_{m−1}&lt;a_m$</p>
<p>4.对于每一个 $k(1≤k≤m)$ 都存在有两个整数 $i$ 和 $j$($0≤i,j≤k−1$,$i$ 和 $j$ 可以相等)，使得$a_k=a_i+a_j$。</p>
<p>给定一些 $n$，寻找最短步数时得到的序列。（输出任意一个解即可）</p>
<p>根据题意，我们可以得知 $a_k$ 的产生方式为 $a_{k-1}$（因为 选择两个非 $a_{k-1}$ 会导致 $a_k$ 小于 $a_{k-1}$）和之前任意的一项。</p>
<p>因为题目要求的是最短的序列，所以我们就可以把数向大赶，这样才能更快的找到解。</p>
<p>同时我们要进行可行性剪枝，设想：$a^k$ 能够产生的最大 $a_m$ 为 $2^ka_k$。所以太小的不会考虑。</p>
<h4 id="最优性剪枝"><a href="#最优性剪枝" class="headerlink" title="最优性剪枝"></a>最优性剪枝</h4><p>当前大于目前答案时直接跳出。</p>
<p>比如前边的课后题 P1460 当当前的维生素袋数大于等于已经搜到的答案可以直接跳出。</p>
<h4 id="额外的题"><a href="#额外的题" class="headerlink" title="额外的题"></a>额外的题</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1074">P1074 靶型数独</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1283">P1283 平板涂色</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1434">P1434 滑雪</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2668">P2668 斗地主</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1731">P1731 生日蛋糕</a></p>
<h3 id="BFS-优化"><a href="#BFS-优化" class="headerlink" title="BFS 优化"></a>BFS 优化</h3><h4 id="双向搜索"><a href="#双向搜索" class="headerlink" title="双向搜索"></a>双向搜索</h4><p>假设我们现在要找网格图两点间的距离，但是存在一些障碍，我们考虑使用 bfs。</p>
<p>这是以起点单点搜索的范围：</p>
<p><img src="/2021/11/20/%E7%BB%88%C2%B7%E6%90%9C%E7%B4%A2/twe1.png" alt></p>
<p>而这是以起点和终点两个起点搜索的范围：</p>
<p><img src="/2021/11/20/%E7%BB%88%C2%B7%E6%90%9C%E7%B4%A2/twe2.png" alt></p>
<p>显然存在差距。</p>
<p>给出一种双向搜索的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()||!q2.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(!q1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(被<span class="number">2</span>标记)</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q2.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(被<span class="number">1</span>标记)</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改队列"><a href="#修改队列" class="headerlink" title="修改队列"></a>修改队列</h4><p>在某些情况下，使用一个裸的队列不能使算法正确，所以我们需要对队列进行一些修改。</p>
<h5 id="例-电路维修"><a href="#例-电路维修" class="headerlink" title="例 电路维修"></a>例 电路维修</h5><p>有一天某辆飞行车没有办法启动了，经过检查发现原来是电路板的故障。飞行车的电路板设计很奇葩，如下图所示：</p>
<p><img src="/2021/11/20/%E7%BB%88%C2%B7%E6%90%9C%E7%B4%A2/dianlu.png" alt></p>
<p>每次可以扭转一个电路板，使“/”与 “\”互换，求最少换几次使左上与右下联通。</p>
<p>解决方法：对于一个点，如果需要一次旋转才能到达目标点，就+1并插入队尾，如果不需要，就直接插入队首，防止 bfs 最优性出现问题。</p>
<p>如果翻转一个电路板要一个特定的价值呢？</p>
<p>把队列改成优先队列即可（也就是一个小根堆）。</p>
<p>这一部分内容无需特别练习，明白如何使用即可。</p>
<h3 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>先来瞟一眼最短路问题。</p>
<p>仔细分析一下，堆优化的Dij其实就是一个优先队列的bfs。</p>
<p>但是这种策略有一个缺点，当前代价较小的的状态，接下来可能有很大的代价。这就导致了最优解可能出现的比较晚。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>我们很自然的想到一个对策，定义一个估价函数 $f(x)$，表示状态 $x$ 到最终状态的代价的咕计值，而每次扩展时依据的是<strong>“当前代价+咕值”最小</strong>的状态。并且，每个状态第一次出队，就是初始状态到它的最优解。</p>
<p>而这个估价函数 $f(x)$ 有一个很重要的性质，假设 $g(x)$为状态 $x$ 到最终状态的实际值，则：</p>
<p>$f(x)\leq g(x)$</p>
<p>我们尝试举个例子：</p>
<p><img src="/2021/11/20/%E7%BB%88%C2%B7%E6%90%9C%E7%B4%A2/alz.png" alt></p>
<p>显而易见，最短路为最左边一条，代价为 17，但是由于这条边上的咕值过大导致结果出错（23），而如果保证 $f(x)]\leq g(x)$。</p>
<p>则即使某非最优解搜索路径上的状态 $s$，由于咕值不够准确，先被扩展了，但是：</p>
<p>由于 $s$ 并非最优，故随着当前代价不断累加，总有一时刻 $s$ 的当前代价大于从初始状态到目标状态的最小代价。</p>
<p>在最优解搜索路径上的状态 $t$，由于 $f(t)\leq g(t)$，故t的当前代价加上 $f(t)$ 小于等于从初始状态到目标状态的最小代价。</p>
<p>综上，$t$ 将被优先取出并扩展，并得到最优解。</p>
<p>而且我们想到，$f(x)$ 越接近 $g(x)$，越能更快得到最优解。</p>
<p>我们只需要把一个使用优先队列的 bfs 加上估价函数，就是 A*。</p>
<h5 id="例-次短路"><a href="#例-次短路" class="headerlink" title="例 次短路"></a>例 次短路</h5><p>方法一：每次记录两个 dis 表示最短和次短，不再多说。</p>
<p>方法二：使用估价函数，其中估价函数 $f(x)$ 表示当前到终点的最短路，当终点第 $k$ 次从队中被取出时，就是 $k$ 短路。</p>
<p>A<em> 板子 A</em> 被卡了！请使用可并堆（另一种数据结构）通过魔法猪学园。</p>
<h5 id="例-P1379-八数码难题"><a href="#例-P1379-八数码难题" class="headerlink" title="例 P1379 八数码难题"></a>例 P1379 八数码难题</h5><p>一个数如果想要恢复原位，必须至少移动曼哈顿距离次。（想一想，为什么）</p>
<p>所以估价函数直接设为一个状态到目标状态的曼哈顿距离之和。</p>
<p>判重随便搞就好，前边有康托，也可以使用 map 或者学习 hash。</p>
<h3 id="迭代加深优化"><a href="#迭代加深优化" class="headerlink" title="迭代加深优化"></a>迭代加深优化</h3><p>ID 的全称：<del>Adobe InDesign</del> iterative deepening search</p>
<p>迭代加深可以从某种意义上减少搜索树的深度，提高程序效率。</p>
<h4 id="IDDFS"><a href="#IDDFS" class="headerlink" title="IDDFS"></a>IDDFS</h4><p>在 DFS 的时候设置一个搜索层数限制，到了一个层数便返回，适合寻找那些奇妙的解。</p>
<p>我们设想一种极端的情况，对于一颗通常的搜索树来说，bfs 的转移十分难设计，而且占用空间，所以一般采用 dfs，但是某些图，dfs 效率十分低，因此我们可以将 IDDFS 视作 dfs+bfs，使 dfs 通过层数限制达到一定的目的。</p>
<p>实际上，限制的最大搜索层数的题都可以视为迭代加深。</p>
<p>例 P1189 ‘SEARCH’</p>
<p>这题如果用 dfs 实际上就要求了层数的限制，因此直接理解为迭代加深就可以了。</p>
<p>现在我们可以对三个基本的搜索(dfs,bfs,iddfs)进行一个比较了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>时间</th>
<th>空间</th>
<th>何时使用？</th>
</tr>
</thead>
<tbody>
<tr>
<td>DFS</td>
<td>$O(b^d)$</td>
<td>$d$</td>
<td>图的规模不是十分离谱</td>
</tr>
<tr>
<td>BFS</td>
<td>$O(b^d)$</td>
<td>$b^d$</td>
<td>空间足够，规范的转移，期望最优答案</td>
</tr>
<tr>
<td>IDDFS</td>
<td>$O(b^d)$</td>
<td>$bd$</td>
<td>空间较小，接受效率的略微降低/限定步数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h4><p>A*+ID,懂？</p>
<p>实际上，A*是对 BFS 的优化。</p>
<p>IDA* 是对结合迭代加深的 DFS 的优化。</p>
<p>本质上是 bfs+dfs+f(x)。</p>
<h4 id="例-P2324-骑士精神"><a href="#例-P2324-骑士精神" class="headerlink" title="例 P2324 骑士精神"></a>例 P2324 骑士精神</h4><p>iddfs 开搜，f(x)：如果是白马设为一个值，如果是黑马设为另一个值，到时候判断是否与最终状态一致决定值就行了。</p>
<p>看到这里，你所有的搜索算法就掌握齐全了，还请各位多加练习，提升自己的搜索能力！</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/training/101475">好 题 单</a></p>
<h2 id="三-私货"><a href="#三-私货" class="headerlink" title="三.私货"></a>三.私货</h2><p>八皇后的时候我曾提到一个其他算法可以解决这个问题，现在我们把它重拾起来。</p>
<p>八皇后看起来十分复杂，我们先换一个问题来解决。</p>
<h5 id="例-矩阵覆盖问题"><a href="#例-矩阵覆盖问题" class="headerlink" title="例 矩阵覆盖问题"></a>例 矩阵覆盖问题</h5><p>给定一个 $N$ 行 $M$ 列的矩阵，矩阵中每个元素要么是1，要么是0</p>
<p>你需要在矩阵中挑选出若干行，使得对于矩阵的每一列 $j$，在你挑选的这些行中，有且仅有一行的第 $j$个元素为 $1$。</p>
<p>首先，不可否认的是，我们可以用搜索解决这个问题，但是我们能否用另一种方式呢？</p>
<h4 id="X-算法"><a href="#X-算法" class="headerlink" title="X 算法"></a>X 算法</h4><p>X 算法</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/163/1813557642.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci='7cdefc0e28e1038270aa'
        data-cs='1cb4132dfb1fa349de23f309aef73e7860ab7004'
        data-r='logfk.github.io'
        data-o='logfk'
        data-a='logfk'
        data-d='true'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="https://lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
